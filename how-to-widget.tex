\section{How to create a Widget}
\subsection{Overview}
This capital is a short guide on how to write new widgets. This guide consists of 3 parts:
\begin{itemize}
    \item \textbf{KNX widget - Scala}
        shows you how to implement new KNX widgets just by extending some classes and overwriting some translate methods.
    \item \textbf{KNX widget - JavaScript}
        is a more detailed look on the widget support in sombrero from a JavaScript perspective. This guide should be useful if you need to implement a new UI for a KNX widget.
    \item \textbf{Widgets from scratch}
         will show you how to implement non-KNX based widgets on the example of the room link widget.
\end{itemize}

To understand how widgets in sombrero work you need to understand the widget life cycle.
After a page request has been send to the server, it will be dispatched and the respective page will be generated by Lift. If you load a room view page, sombrero loads all widgets in the respective room from the Database and generates widgets. After that these widgets are rendered into the page, it will be sent to the client. In the next step the browser renders the site and after it's fully loaded all widgets get initialized. Now they are ready for user interaction. If the user performs an interaction which requires server side processing, a callback on the server is invoked via AJAX. There are two possible ways for the server to react and depending on the implementation one is used. The first solution just sends JavaScript commands back, which are later evaluated on the client. The other one is to return nothing to the client and send a request to the distributor actor. The distributer processes the request and sends to all clients affected by the request (using Comet JavaScript) commands to update the UI on the client.

The JavaScript part of the widgets is located in the folder toserve/widgets/js. If a widget needs a great amount of special CSS styles they are outsourced in the folder toserve/widgets/css. All widget Scala files are placed in the package org.sombrero.widget except KNX widgets, which can be found in the org.sombrero.widget.knx package.

\subsection{KNX widget - Scala}
    To bring more structure and modularity to this mess of KNX device widgets we split them into categories. First we differentiate between widgets that have state and ones that are only able to receive commands.

    I think command widgets are rarely used, but can be a nice platform for simple testing of devices. The switch, switch off and switch off are already implemented devices using command widget as a super class.
\begin{lstlisting}[caption=CommandWidget: discovery.html,label=lst:h2h:commandwidget]
abstract class CommandWidget(data: model.Widget, widgetType: String, wp: WidgetPlace) extends Widget(data, widgetType, wp) {

    .
    .

 	/* This method translates a value received from the client into a comprehensible form
     * for the KNX/EIB device encapsulated in this class.
     *
     * @param value is a String received from the client with a range from 0 - 100
     * @returns a String which should be understandable for the devices it will be sent to
 	 */
    def translate(value: String): String
}
\end{lstlisting}

    StateWidget inherits from CommandWidget, because every widget with a state is probably able to change this state. Most KNX widgets have to inherit from this class. Examples of widgets inheriting from this class are lamp, temperature actuator, dimmer and roller blind.
\begin{lstlisting}[caption=StateWidget: Widget.scala,label=lst:h2h:statewidget]
abstract class StateWidget(data: model.Widget, widgetType: String, wp: WidgetPlace) extends CommandWidget(data, widgetType, wp) {

    .
    .

   /* This method translates a value from a KNX/EIB device into an comprehensible form
    * for the clients JavaScript widget encapsulated in this class
    *
    * @param value is a Array[Byte] received from a KNX device
    * @returns a String that will be sent to the client it should hold value between 0 - 100
    */
    def translate(value: Array[Byte]): String
}
\end{lstlisting}

    If you want to implement a new KNX widget, it has to inherit from one of these classes above and implement their abstract methods. When you inherit from one of these classes there are two constructor parameters you need to assign a value to. The one called data can only be assigned by instantiation, because data is an instance of an model.Widget class. That's why it contains all meta data needed to create the widget, like its KNX address or position on site. So it has to be assigned in the constructor of the new class. The other parameter is called widgetType and will be explained in the next paragraph. Another thing you should be careful about is the member variable properties. It contains all properties that will be given as parameters to the JavaScript widget on initialization. All configuration of the UI and JavaScript part of the widgets can be done with this Map. The key is the name of the property and the value is the property's value. To learn more about properties of widget read the chapter JavaScript and JQuery again.

    This form of distinction between KNX device widgets wasn't enough to ensure great modularity, because to keep boilerplate code as small as possible we had to build the same abstraction on the JavaScript level. We discovered that with these two forms of widgets, we wouldn't be able to code the UI and JavaScript part in a modular way. So we decided to create three different widget types. These types are all implemented as standalone widgets and can be configured to become the widgets described in the chapter User Mode.

    Here a list of all available types:
\begin{itemize}
    \item \textbf{unary}
    
        This widget form is equivalent to the command widget. It is possible to configure the picture displayed in the content area. If you click in the content area of the widget a command is sent to the server.

        By inserting this line into the constructor of your new widget the picture in the content area is set to /images/Toogle.png.
\begin{lstlisting}[caption=widget configuration unary: Switch.scala,label=lst:h2h:unaryconfig]
properties ++ Map("img" -> "\"/images/Toggle.png\"")         //img is always displayed
\end{lstlisting}
    \item \textbf{binary}
    
        The binary widgets have two states. It is possible to assign to each state a picture. By clicking in the content area of the widget a command is sent to the server and later a update per Comet is received.

        By inserting this lines into the constructor of your new widget, you can set the pictures displayed in each state.
\begin{lstlisting}[caption=widget configuration binary,label=lst:h2h:binaryconfig]
properties ++ Map(
    "imgOn"  -> "\"/images/lightbulb1.png\"",		             //img displayed if state = true
    "imgOff" -> "\"/images/lightbulb1off.png\""                //img displayed if state = false
)
\end{lstlisting}
    \item \textbf{analog}
    
        This widget form is probably the most common and complex one.
        
        A short introduction to the most important properties:
        \begin{itemize}
            \item \textbf{foreground image}


                This image will always be displayed in foreground.

                \lstinline!frontImg = path!
            \item \textbf{background image}


                This image will always be displayed behind the foreground image.

                \lstinline!backgroundImg = path!
            \item \textbf{which image has to be clipped}


                This property determines which of the two images mentioned above should be clipped. Clipping refers to the CSS property clip, which allows you to cut displayed parts of a selected tag. So this feature gives the widget this feeling of changing the state intuitive. If you want to learn more about this topic read chapter How to use sombrero - User Mode.

                \lstinline!clip_front = true  - the foreground image will be clipped!

                \lstinline!clip_front = false - the background image will be clipped!
            \item \textbf{sliding rectangular}


                By setting this property you determine the area which will be used for sliding to change the state of the widget. All values are relative to the position upper left corner of the content area.

                \lstinline!slideRect = [top, left, height, width]!
            \item \textbf{opacity image}


                This image, if set, will be placed before the foreground widget. It's opacity changes percental to the current state.

                \lstinline!opacity = path!
            \item \textbf{reverse}


                This property allows you to decide if sliding should be top down or bottom up. The lamp and temperature widget are set to top down and the roller blind widget uses bottom up.

                \lstinline!reverse = true  - sliding bottom up!

                \lstinline!reverse = false - sliding top down!
        \end{itemize}

        By inserting one of the following code examples into the constructor of your new widget, you can configure it to look and feel like one of the already finished widgets.
        \begin{itemize}
            \item \textbf{roller blind}
\begin{lstlisting}[caption=widget configuration roller blind: Rollo.scala,label=lst:h2h:rollerblindconfig]
properties ++ Map(
	"frontImg" -> "\"/images/rollo0zu.png\"",
	"backgroundImg" -> "\"/images/rollo0.png\"",
	"slideRect" -> "[19, 19, 122, 122]",
    "reverse" -> "true"
)
\end{lstlisting}
            \item \textbf{temperature actuator}
            \begin{lstlisting}[caption=widget configuration temperature actuator: Temperature.scala,label=lst:h2h:temperatureconfig]
properties ++ Map(
    "clip_front" -> "true"
)
\end{lstlisting}
            \item \textbf{dimmer}
\begin{lstlisting}[caption=widget configuration dimmer: Dimmer.scala,label=lst:h2h:dimmerconfig]
properties ++ Map(
    "frontImg" -> "\"/images/dim0drag.png\"",
	"backgroundImg" -> "\"/images/dim0.png\"",
	"slideRect" -> "[19, 90, 122, 42]",
	"opacity" -> "\"/images/dim0light.png\""
)
\end{lstlisting}
        \end{itemize}
\end{itemize}

To enable KNX support for your new widget, you have to choose the DataPoint of the respective device. There are two categories of KNX devices. One with state and one without. To implement the KNX functionalities you have to write a subclass and implement all abstract methods.

The class CommandKNXWidget should be inherited if you want to use a device without state:
\begin{lstlisting}[caption=KNX command widget: Widget.scala,label=lst:h2h:commandknxwidget]
/* KNXWidget is the super class of the two specified KNX device
 * classes which implement KNX functionality.
 *
 * @type T is a type that should be specified in the last sub
 * class of KNXWidget. This type was built to maintain type
 * conformity.
 */

abstract class KNXWidget[T](destAddress:String, name:String, mainNumber:Int, dptID:String){
	System.out.println(destAddress);
    val destDevice = new GroupAddress(destAddress)
    val dptx: DPTXlator
    val dp: Datapoint

    /* Translate takes a value of type T and transforms it into a
     * String understandable for the KNX device.
     * It was created to maintain type conformity during the
     * sending process of commands.
     */
    def translate (value: T): String

	def write (status: T) = if(Connection.isConnected) Connection.knxComm.write(dp, translate(status))
	def write (status: String) = if(Connection.isConnected) Connection.knxComm.write(dp, status)
}

/* CommandKNXWidget is the super class of all classes which
 * implement Command KNX functionality
 */
abstract class CommandKNXWidget [T] (destAddress:String, name:String, mainNumber:Int, dptID:String)
		 extends KNXWidget[T] (destAddress, name, mainNumber, dptID){
    override val dp = new CommandDP(destDevice, name, mainNumber, dptID)
}
\end{lstlisting}

The class StateKNXWidget should be inherited if you want to use a device with state enabled:
\begin{lstlisting}[caption=KNX state widget: Widget.scala,label=lst:h2h:stateknxwidget]
abstract class StateKNXWidget[T] (destAddress:String, name:String, mainNumber:Int, dptID:String)
		 extends KNXWidget[T](destAddress, name, mainNumber, dptID){
    override val dp = new StateDP(destDevice, name, mainNumber, dptID)

    /* This method takes a value of type String and transforms it
     * into it's respective type.
     * It was written to transform Strings received from a device
     * into it's respective type.
     */
    def translate (value: String): T

    /* This method takes a value of type Array[Byte] and transforms it into a String understandable for humans
     */
    def translate (value: Array[Byte]): String

	def getStatus (): Box[T] = {
	  if(Connection.isConnected){
		  Log.info(Connection.knxComm.toString)
		  Full(translate(Connection.knxComm.read(dp)))
	  }else
         Empty
	}
}
\end{lstlisting}

Here is an example of an already implemented KNX widget with state using binary as a widgetTyp:
\begin{lstlisting}[caption=widget lamp: Lamp.scala,label=lst:h2h:lampwidget]
class Lamp (data: org.sombrero.model.Widget, wp: WidgetPlace) extends StateWidget(data, "binary", wp){
   val knx = new KNXLamp(data.knx().groupAddress.is)
   var status:Boolean = knx.getStatus match {
     case Full(x: Boolean)	=> x
     case _					=> false
   }

   properties ++ Map(
     	"value" -> status.toString
   )
   //sets the path to a helptext URL which can be accessed in Admin Mode
   helpUrl = "/helptext/lamp"

   def translate(value: Array[Byte]): String = knx.translate(knx.translate(value)).toString
   def translate(value: String): String = {
      Log.info("I'm a Lamp tell me what to do");
      knx.translate(! value.toBoolean)
   }
}

class KNXLamp (destAddress:String)
	extends StateKNXWidget [Boolean](destAddress, "Lamp",
			TranslatorTypes.TYPE_BOOLEAN, DPTXlatorBoolean.DPT_SWITCH.getID){
	val dptx = new DPTXlatorBoolean (DPTXlatorBoolean.DPT_SWITCH.getID)

    def translate (value: Boolean): String = {
      dptx.setValue(value)
      dptx.getValue
    }

    def translate (value: String): Boolean = {
      dptx.setValue(value)
      dptx.getValueBoolean
    }

    def translate (value: Array[Byte]): String = {
		dptx.setData(value)
		dptx.getValue
    }
}
\end{lstlisting}

\subsection{KNX widget - JavaScript}
    If you read the previous chapter, you should now be able to implement new KNX widgets with Sombrero's three widget types, but what if want to built a more complex widget? To get some more insight on that part I will show you how we implemented the analog widget. Before reading this chapter you should have read the chapter about how to create JQuery widgets.

    JavaScript sombrero widgets are usually initialized using empty div tags. These tags will be filled with the respective mock-up to make them look and feel like stylish widgets. All the configuration for the widgets is done trough options.

    Because inheritance isn't really supported by JQuery widgets I decided to take another approach to this modularity problem. The solution was to outsource all redundant code into another widget, called protowidget.

    A first look at the \_init method of protowidget:
\begin{lstlisting}[caption=prototype widget - init: ui.protowidget.js ,label=lst:h2h:protowidgetinit]
_init: function (){
	var that = this;                      //this is a helper variable to access this in anonymous functions
	this.hoff = this._getData('hoff');
	this.off = this._getData('off');
	
	this.element
    //these CSS classes give the widget the JQuery UI CSS framework look
	.attr("class", "ui-state-default ui-corner-all")
    //setting all style information that was given by the options
    //this._getData('top') = this.options.top
	.css({
		position: 	"absolute",
		border: 	"1px solid black",
		height: 	(this._getData('height')+this.hoff+this.off) + "px",
		width:		(this._getData('width')+this.off) + "px",
		top: 		this._getData('top') + "px",
		left: 		this._getData('left') + "px"})
    //the hover event
	.hover(function(){ that.mouseOn(); },
			function(){ that.mouseOff(); });   	

	this.toolbox();       //adds the admin toolbox to the widget
	this.draggable();     //adds draggable functionality
	this.titlebar();      //adds the title bar to the widget
}
\end{lstlisting}

    Protowidget consists of the following functionalities:
    \begin{itemize}
        \item \textbf{draggable}

            This feature enables the widgets to be draggable. For this functionality the standard JQuery UI draggable implementation with a small extension is used. The surrounding div tag is used as an associated DOM element.

\begin{lstlisting}[caption=prototype widget - draggable: ui.protowidget.js ,label=lst:h2h:protowidgetdrag]
draggable: function(){
    var that = this;

	this.element.draggable({
		snap: true,
        //enables snapping between widgets
		
        snapMode: "both",
		snapTolerance: "10",
		cancel: this._getData('cancel'),
        //By specifying the property cancel you can
        //state an area that doesn't allow dragging
        //this feature is used by the analog widget
		
        stop: function(event, ui){
        //this function is called when the user stops dragging

				that._setData('top', ui.position.top);
				that._setData('left', ui.position.left);
				that._getData('stop')();
				that._setData('isDragged', true);
		},
		collide: "block",
        //enables collision detection

		containment: this._getData('parentTag')
        //sets a containment tag, which limits
        //widget movement to this area
	});
}
\end{lstlisting}

        \item \textbf{admin toolbox}

            This feature is responsible for the admin toolbox. The protowidget automatically generates the admin toolbox, by specifying the icons that should be used, the callback that should be called and the urls which specify the location for the dialogs. If you want to learn more on this topic feel free to browse through the code.
        \item \textbf{title bar}

            The protowidget also generates the title bar for you. The only thing you need to specify is the title.
        \item \textbf{on hover style change}

            This feature enables the widget to change it's look to a JQuery UI CSS framework hover-look, when the mouse is over the widget.

\begin{lstlisting}[caption=hover widget, label=lst:h2h:hoverwidget]
mouseOn: function(){
	if(!this._getData('hoveroff')) this.element.addClass("ui-state-hover");
},
mouseOff: function(){
	if(!this._getData('hoveroff')) this.element.removeClass("ui-state-hover");
}
\end{lstlisting}

        \item \textbf{copying and moving}

            Copying and moving was developed for the favorites widget and the admin side bar. To enable coping you need to implement the function createCopy. The function should return a copy of the current widget and set is\_active to true and set the parentObj property to the current element.

        Here is an example that shows you how to do so:
\begin{lstlisting}[caption=copy widget, label=lst:h2h:copywidget]
var this = that;

this.element.protowidget( $.extend({}, this.options, {
    createCopy: function(){
		return $('<div></div>').widgetname($.extend({}, that.options, {
			is_active: true,
			parentObj: that.element
		}));
	}
}));
\end{lstlisting}
        \item \textbf{style information}

            By tweaking some options, you can change the style of the widget, for instance height, width or even the position through top and left.
    \end{itemize}
    Every self-built widget that's supposed to be in the main area of the site should use protowidget to enable standard functionality.

Here is an already implemented example:
\begin{lstlisting}[caption=binaray widget: ui.binary.js ,label=lst:h2h:binarywidget]
(function($) {

$.widget("ui.binary", {
	_init: function (){
		var that = this;

		if(this._getData('value'))
			var img = this._getData('imgOn');
		else
			var img = this._getData('imgOff');

		this.element.protowidget( $.extend({}, this.options, {
			createCopy: function(){
				return $('<div></div>').binary($.extend({}, that.options, {
					is_active: true,
					parentObj: that.element
				}));
			}
		}));
		
		this.img = $("<img></img>")
		.css({
			position: 	"absolute",
			height: 	(this._getData('height')) + "px",
			width:		(this._getData('width'))  + "px",
			top: 		this.element.protowidget('option', 'hoff') + "px",
			left: 		"0px"})
		.attr("src", img)
		.click(function (){
			if(!that.element.protowidget('option', 'isDragged'))
				that._getData('change')();
			else
				that.element.protowidget('option', 'isDragged', false);
		})
		.appendTo(this.element);
		
	},
   /* This function should be implemented in every widget with
    * state because it is used as a standard callback by the
    * widget class.
    */
	update_value: function(newValue){
		if(newValue)
			this.img.attr("src", this._getData('imgOn'));
		else
			this.img.attr("src", this._getData('imgOff'));
		this._setData('value', newValue);
	}
});

$.extend($.ui.binary, {
    version: "1.0",     //version number
    defaults: {

top: 0,                 //top value of the widget
left: 0,                //left value of the widget
height: 160,            //height value of the widget
width: 160,	            //width value of the widget
imgOn: "/images/lightbulb1.png",
//img in widget when value = true

imgOff: "/images/lightbulb1off.png",
//img in widget when value = false

click: function(){},    //callback is called on click
stop: function(){},     //callback is called when drag stopped
prefix: "lamp",         //prefix for the id atribute
admin: null,            //true = admin mode - false = normal mode
admin_img: [     "ui-icon-help",
                 "ui-icon-wrench",	
                 "ui-icon-trash",	
                 "ui-icon-minus"],
//array filled with css classes to display
//the clickable icons of the admin widget

admin_onClick: [ function(){},	
                 function(){},		
                 function(){},
                 function(){}],
//callback is called on the click on
//the associated icon of the admin widget

text: "",              //text for the title bar
is_active: false,
//determines if a widget is in the favorites bar or not

favorites: null,
//reference to the JQuery object of the favorites bar

parentTag: null,
//reference to the JQuery object of the main area

active: 	   function(){},
//this callback is called when a widget is promoted to favorite

inactive: 	   function(){},
//this callback is called when a widget looses it's
//favorite status

admin_url: 		[ "",
           		  "" ],
//these strings are urls that are used for creating the help and
//the configuration dialog

in_toolbox:		function(){},
//this callback is called when a widget is moved to the
//admin sidebar

out_toolbox:	function(){},
//this callback is called when a widget is removed from the
//admin sidebar

value: true,		     //true -> on; false -> off

change:			function(){}
//this callback is called when the status of the lamp was
//changed by clicking

	}
});
})(jQuery);

\end{lstlisting}

\subsection{Widgets from scratch}
So far I have shown you how to implement non-KNX widgets and implementing a non KNX widget isn't really different at all.

First you have to create a scala class and let it inherit from org.sombrero.widget.Widget. Then you set the parameter widgetType to the name of the JQuery widget you want to use and as before don't specify data yet. This will be done automatically by the WidgetList class. After that you can add or remove some properties. The next step would be to write the JavaScript part of the widget and after you are done with everything skip to the chapter and read how to write the database part of a widget. After that you should put the widget into the widget list.

This is a modified example of the class WidgetList, where the widget TheWidget was added:
\begin{lstlisting}[caption=widget list ,label=lst:h2h:widgetlist]
object WidgetList {
  case class WidgetClass[T <: model.WidgetData[T]] (name : String, id : String, data : model.WidgetMetaData[T], factory : (model.Widget) => widget.Widget)

  val map = Map(
  "Lamp"        -> WidgetClass[model.KNXWidget]
  ("Lamp", "Lamp", model.KNXWidget, new Lamp(_)),

  "Temperature" -> WidgetClass[model.KNXWidget]
  ("Temperature", "Temperature", model.KNXWidget,
        new Temperature(_)),

  "SwitchOn"    -> WidgetClass[model.KNXWidget]
  ("SwitchOn", "SwitchOn", model.KNXWidget, new SwitchOn(_, _)),

  "SwitchOff"   -> WidgetClass[model.KNXWidget]
  ("SwitchOff", "SwitchOff", model.KNXWidget, new SwitchOff(_, _)),

  "Switch"      -> WidgetClass[model.KNXWidget]
  ("Switch", "Switch", model.KNXWidget, new Switch(_, _)),

  "Dimmer"      -> WidgetClass[model.KNXWidget]
  ("Dimmer", "Dimmer", model.KNXWidget, new Dimmer(_, _)),

  "Rollo"       -> WidgetClass[model.KNXWidget]
  ("Rollo", "Rollo", model.KNXWidget, new Rollo(_, _)),

  "Roomlink"    -> WidgetClass[model.RoomlinkWidget]
  ("Roomlink", "Roomlink", model.RoomlinkWidget, new RoomLink(_, _)),

  "TheWidget"   -> WidgetClass[model.TheWidget]
  ("TheWidget", "TheWidget", model.TheWidget, new TheWidget(_, _)))

 val default = map("Lamp")
}
\end{lstlisting}

If you really want to create a new widget by yourself you should look into the JavaScriptHelper class. There are some quite neat functions for interaction with JQuery widgets and before you start to code your first widget by yourself you should have a look into the file Widget.scala.